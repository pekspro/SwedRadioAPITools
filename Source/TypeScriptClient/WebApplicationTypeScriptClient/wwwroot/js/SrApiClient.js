"use strict";
/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
class SrApiClient {
    constructor(baseUrl, http) {
        this.jsonParseReviver = undefined;
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.sr.se/api/v2";
    }
    /**
     * Get channels.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param sort (optional)
     * @param liveAudioTemplateId (optional) Valid values are 2-5 and 10-12. Will be 2 (mp3) if omitted.
     * @param audioquality (optional) Only supported then liveAudioTemplateId is 2-5.
     * @return OK
     */
    getChannels(format, page, size, sort, liveAudioTemplateId, audioquality) {
        let url_ = this.baseUrl + "/channels?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (liveAudioTemplateId === null)
            throw new Error("The parameter 'liveAudioTemplateId' cannot be null.");
        else if (liveAudioTemplateId !== undefined)
            url_ += "liveAudioTemplateId=" + encodeURIComponent("" + liveAudioTemplateId) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetChannels(_response);
        });
    }
    processGetChannels(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ChannelsResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get a single channel.
     * @param format Format of response. Has to be json.
     * @param id Id of channel
     * @param liveAudioTemplateId (optional) Valid values are 2-5 and 10-12. Will be 2 (mp3) if omitted.
     * @param audioquality (optional) Only supported then liveAudioTemplateId is 2-5.
     * @return OK
     */
    getChannel(format, id, liveAudioTemplateId, audioquality) {
        let url_ = this.baseUrl + "/channels/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (liveAudioTemplateId === null)
            throw new Error("The parameter 'liveAudioTemplateId' cannot be null.");
        else if (liveAudioTemplateId !== undefined)
            url_ += "liveAudioTemplateId=" + encodeURIComponent("" + liveAudioTemplateId) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetChannel(_response);
        });
    }
    processGetChannel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ChannelResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get program categories.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getProgramCategories(format, page, size) {
        let url_ = this.baseUrl + "/programcategories?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetProgramCategories(_response);
        });
    }
    processGetProgramCategories(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProgramCategoriesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get a single program category.
     * @param format Format of response. Has to be json.
     * @param id Id of program category
     * @return OK
     */
    getProgramCategory(format, id) {
        let url_ = this.baseUrl + "/programcategories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetProgramCategory(_response);
        });
    }
    processGetProgramCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProgramCategoryResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get programs.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param programCategoryId (optional)
     * @param isArchived (optional) If program should be archived
     * @return OK
     */
    getPrograms(format, page, size, programCategoryId, isArchived) {
        let url_ = this.baseUrl + "/programs?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programCategoryId === null)
            throw new Error("The parameter 'programCategoryId' cannot be null.");
        else if (programCategoryId !== undefined)
            url_ += "programCategoryId=" + encodeURIComponent("" + programCategoryId) + "&";
        if (isArchived === null)
            throw new Error("The parameter 'isArchived' cannot be null.");
        else if (isArchived !== undefined)
            url_ += "isArchived=" + encodeURIComponent("" + isArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPrograms(_response);
        });
    }
    processGetPrograms(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProgramsResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get a single program.
     * @param format Format of response. Has to be json.
     * @param id Id of program
     * @return OK
     */
    getProgram(format, id) {
        let url_ = this.baseUrl + "/programs/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetProgram(_response);
        });
    }
    processGetProgram(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProgramResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get episodes.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getEpisodes(format, page, size, programId, fromDate, toDate, audioquality) {
        let url_ = this.baseUrl + "/episodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined and cannot be null.");
        else
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetEpisodes(_response);
        });
    }
    processGetEpisodes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EpisodesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get a single episode.
     * @param format Format of response. Has to be json.
     * @param id Id of episode
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getEpisode(format, id, audioquality) {
        let url_ = this.baseUrl + "/episodes/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetEpisode(_response);
        });
    }
    processGetEpisode(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EpisodeResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Search episodes.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page. For episode search this cannot be more than 25.
     * @param query String to be search in episodes. For instance 'mask'
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    searchEpisodes(format, page, size, query, audioquality) {
        let url_ = this.baseUrl + "/episodes/search?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processSearchEpisodes(_response);
        });
    }
    processSearchEpisodes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = EpisodesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get current playlist for a channel.
     * @param format Format of response. Has to be json.
     * @param channelid Id of channel
     * @return OK
     */
    getPlaylistRightNow(format, channelid) {
        let url_ = this.baseUrl + "/playlists/rightnow?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (channelid === undefined || channelid === null)
            throw new Error("The parameter 'channelid' must be defined and cannot be null.");
        else
            url_ += "channelid=" + encodeURIComponent("" + channelid) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylistRightNow(_response);
        });
    }
    processGetPlaylistRightNow(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RightNowPlaylistResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get playlist for an channel.
     * @param format Format of response. Has to be json.
     * @param size (optional) Maximum number of songs to get. Default is 20.
     * @param id Id of channel
     * @param startDateTime (optional) From which time. If not provided, current date will be used.
     * @param endDateTime (optional) To which time. If not provided, startDateTime + 1 day will be used.
     * @return OK
     */
    getPlaylistByChannel(format, size, id, startDateTime, endDateTime) {
        let url_ = this.baseUrl + "/playlists/getplaylistbychannelid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toJSON() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylistByChannel(_response);
        });
    }
    processGetPlaylistByChannel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SonglistResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get playlist for a program.
     * @param format Format of response. Has to be json.
     * @param size (optional) Maximum number of songs to get. Default is 20.
     * @param id Id of program
     * @param startDateTime (optional) From which time. If not provided, current date will be used.
     * @param endDateTime (optional) To which time. If not provided, startDateTime + 1 day will be used.
     * @return OK
     */
    getPlaylistByProgram(format, size, id, startDateTime, endDateTime) {
        let url_ = this.baseUrl + "/playlists/getplaylistbyprogramid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toJSON() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylistByProgram(_response);
        });
    }
    processGetPlaylistByProgram(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SonglistResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get playlist for an episode.
     * @param format Format of response. Has to be json.
     * @param id Id of epsiode
     * @return OK
     */
    getPlaylistByEpisode(format, id) {
        let url_ = this.baseUrl + "/playlists/getplaylistbyepisodeid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylistByEpisode(_response);
        });
    }
    processGetPlaylistByEpisode(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SonglistResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not found", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get news programs.
     * @param format Format of response. Has to be json.
     * @return OK
     */
    getNewsPrograms(format) {
        let url_ = this.baseUrl + "/news?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetNewsPrograms(_response);
        });
    }
    processGetNewsPrograms(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NewsProgramsResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get news episodes.
     * @param format Format of response. Has to be json.
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getNewsEpisodes(format, audioquality) {
        let url_ = this.baseUrl + "/news/episodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetNewsEpisodes(_response);
        });
    }
    processGetNewsEpisodes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NewsEpisodesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get extra broadcasts.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getExtraBroadcasts(format, page, size) {
        let url_ = this.baseUrl + "/extra/broadcasts?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetExtraBroadcasts(_response);
        });
    }
    processGetExtraBroadcasts(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ExtraBroadcastsResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get scheduled episodes for a channel.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param channelId Id of channel.
     * @param date (optional) Date for schedule. If no date is provided current date will be used.
     * @return OK
     */
    getScheduledEpisodesForChannel(format, page, size, channelId, date) {
        let url_ = this.baseUrl + "/scheduledepisodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined and cannot be null.");
        else
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetScheduledEpisodesForChannel(_response);
        });
    }
    processGetScheduledEpisodesForChannel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ScheduledEpisodeResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get scheduled episodes for a program.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param programId Id of program.
     * @param fromdate (optional) From date for schedule. If only fromdate is provided schedule for the that date and the 21 days is returned.
     * @param todate (optional) To date for schedule. If only todate is provided schedule from today until todate is returned.
     * @return OK
     */
    getScheduledEpisodesForProgram(format, page, size, programId, fromdate, todate) {
        let url_ = this.baseUrl + "/scheduledepisodes/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined and cannot be null.");
        else
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (fromdate === null)
            throw new Error("The parameter 'fromdate' cannot be null.");
        else if (fromdate !== undefined)
            url_ += "fromdate=" + encodeURIComponent(fromdate ? "" + fromdate.toJSON() : "") + "&";
        if (todate === null)
            throw new Error("The parameter 'todate' cannot be null.");
        else if (todate !== undefined)
            url_ += "todate=" + encodeURIComponent(todate ? "" + todate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetScheduledEpisodesForProgram(_response);
        });
    }
    processGetScheduledEpisodesForProgram(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ScheduledEpisodeResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get was is playing right now on each channel.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getEpisodesRightNowAllChannels(format, page, size) {
        let url_ = this.baseUrl + "/scheduledepisodes/rightnow?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetEpisodesRightNowAllChannels(_response);
        });
    }
    processGetEpisodesRightNowAllChannels(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ChannelsRightNowResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get was is playing right now on a single  channel.
     * @param format Format of response. Has to be json.
     * @param channelId Id of channel.
     * @return OK
     */
    getEpisodesRightNowForChannel(format, channelId) {
        let url_ = this.baseUrl + "/scheduledepisodes/rightnow/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined and cannot be null.");
        else
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetEpisodesRightNowForChannel(_response);
        });
    }
    processGetEpisodesRightNowForChannel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ChannelRightNowResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get latest published broadcasts and pods.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param audioquality (optional)
     * @return OK
     */
    getLastPublishedShows(format, page, size, audioquality) {
        let url_ = this.baseUrl + "/lastpublished?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetLastPublishedShows(_response);
        });
    }
    processGetLastPublishedShows(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = LastPublishedShowsResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get important messages.
     * @param format Format of response. Has to be json.
     * @return OK
     */
    getImportantMessages(format) {
        let url_ = this.baseUrl + "/vma?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetImportantMessages(_response);
        });
    }
    processGetImportantMessages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = MessagesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get traffic areas.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getTrafficAreas(format, page, size) {
        let url_ = this.baseUrl + "/traffic/areas?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetTrafficAreas(_response);
        });
    }
    processGetTrafficAreas(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TrafficAreasResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get traffic area for a specific coordinate.
     * @param format Format of response. Has to be json.
     * @param latitude Latitude. Valid values -90 to 90.
     * @param longitude Longitude. Valid values -180 to 180.
     * @return OK
     */
    getTrafficArea(format, latitude, longitude) {
        let url_ = this.baseUrl + "/traffic/areas/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetTrafficArea(_response);
        });
    }
    processGetTrafficArea(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TrafficAreaResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get traffic messages.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param trafficAreaName (optional) Name of traffic area.
     * @return OK
     */
    getTrafficMessages(format, page, size, trafficAreaName) {
        let url_ = this.baseUrl + "/traffic/messages?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (trafficAreaName === null)
            throw new Error("The parameter 'trafficAreaName' cannot be null.");
        else if (trafficAreaName !== undefined)
            url_ += "trafficAreaName=" + encodeURIComponent("" + trafficAreaName) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetTrafficMessages(_response);
        });
    }
    processGetTrafficMessages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TrafficMessagesResponse.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
var Format;
(function (Format) {
    Format["Json"] = "json";
})(Format || (Format = {}));
var ChannelSort;
(function (ChannelSort) {
    ChannelSort["Id"] = "id";
    ChannelSort["Id_desc"] = "id desc";
    ChannelSort["Name"] = "name";
    ChannelSort["Name_desc"] = "name desc";
})(ChannelSort || (ChannelSort = {}));
/** Seems to be supported by live audio template 2-5. Read more about details at https://sverigesradio.se/api/documentation/v2/metoder/ljud.html#kvalitet */
var AudioQuality;
(function (AudioQuality) {
    AudioQuality["Normal"] = "normal";
    AudioQuality["Hi"] = "hi";
    AudioQuality["Lo"] = "lo";
})(AudioQuality || (AudioQuality = {}));
class Pagination {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.page = _data["page"];
            this.size = _data["size"];
            this.totalhits = _data["totalhits"];
            this.totalpages = _data["totalpages"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Pagination();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["size"] = this.size;
        data["totalhits"] = this.totalhits;
        data["totalpages"] = this.totalpages;
        return data;
    }
}
class BaseResponse {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.copyright = _data["copyright"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["copyright"] = this.copyright;
        return data;
    }
}
class PaginationResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.pagination = new Pagination();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.pagination = _data["pagination"] ? Pagination.fromJS(_data["pagination"]) : new Pagination();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["pagination"] = this.pagination ? this.pagination.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class LiveAudio {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new LiveAudio();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        return data;
    }
}
class SocialMediaPlatform {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.platform = _data["platform"];
            this.platformurl = _data["platformurl"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SocialMediaPlatform();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["platform"] = this.platform;
        data["platformurl"] = this.platformurl;
        return data;
    }
}
class Channel {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.imagetemplate = _data["imagetemplate"];
            this.color = _data["color"];
            this.tagline = _data["tagline"];
            this.siteurl = _data["siteurl"];
            this.liveaudio = _data["liveaudio"] ? LiveAudio.fromJS(_data["liveaudio"]) : undefined;
            this.scheduleurl = _data["scheduleurl"];
            this.channeltype = _data["channeltype"];
            this.xmltvid = _data["xmltvid"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["imagetemplate"] = this.imagetemplate;
        data["color"] = this.color;
        data["tagline"] = this.tagline;
        data["siteurl"] = this.siteurl;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : undefined;
        data["scheduleurl"] = this.scheduleurl;
        data["channeltype"] = this.channeltype;
        data["xmltvid"] = this.xmltvid;
        return data;
    }
}
class ChannelOverview {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelOverview();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
class ChannelsResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.channels = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["channels"])) {
                this.channels = [];
                for (let item of _data["channels"])
                    this.channels.push(Channel.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.channels)) {
            data["channels"] = [];
            for (let item of this.channels)
                data["channels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ChannelResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.channel = new Channel();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.channel = _data["channel"] ? Channel.fromJS(_data["channel"]) : new Channel();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class ProgramCategory {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategory();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
class ProgramCategoriesResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.programcategories = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["programcategories"])) {
                this.programcategories = [];
                for (let item of _data["programcategories"])
                    this.programcategories.push(ProgramCategory.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategoriesResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programcategories)) {
            data["programcategories"] = [];
            for (let item of this.programcategories)
                data["programcategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ProgramCategoryResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.programcategory = new ProgramCategory();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.programcategory = _data["programcategory"] ? ProgramCategory.fromJS(_data["programcategory"]) : new ProgramCategory();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategoryResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["programcategory"] = this.programcategory ? this.programcategory.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class Program {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.programcategory = _data["programcategory"] ? ProgramCategory.fromJS(_data["programcategory"]) : undefined;
            this.payoff = _data["payoff"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.broadcastinfo = _data["broadcastinfo"];
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : undefined;
            if (Array.isArray(_data["socialmediaplatforms"])) {
                this.socialmediaplatforms = [];
                for (let item of _data["socialmediaplatforms"])
                    this.socialmediaplatforms.push(SocialMediaPlatform.fromJS(item));
            }
            this.programurl = _data["programurl"];
            this.programslug = _data["programslug"];
            this.programimage = _data["programimage"];
            this.programimagetemplate = _data["programimagetemplate"];
            this.programimagewide = _data["programimagewide"];
            this.programimagetemplatewide = _data["programimagetemplatewide"];
            this.socialimage = _data["socialimage"];
            this.socialimagetemplate = _data["socialimagetemplate"];
            this.archived = _data["archived"];
            this.hasondemand = _data["hasondemand"];
            this.haspod = _data["haspod"];
            this.responsibleeditor = _data["responsibleeditor"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["programcategory"] = this.programcategory ? this.programcategory.toJSON() : undefined;
        data["payoff"] = this.payoff;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["broadcastinfo"] = this.broadcastinfo;
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        if (Array.isArray(this.socialmediaplatforms)) {
            data["socialmediaplatforms"] = [];
            for (let item of this.socialmediaplatforms)
                data["socialmediaplatforms"].push(item.toJSON());
        }
        data["programurl"] = this.programurl;
        data["programslug"] = this.programslug;
        data["programimage"] = this.programimage;
        data["programimagetemplate"] = this.programimagetemplate;
        data["programimagewide"] = this.programimagewide;
        data["programimagetemplatewide"] = this.programimagetemplatewide;
        data["socialimage"] = this.socialimage;
        data["socialimagetemplate"] = this.socialimagetemplate;
        data["archived"] = this.archived;
        data["hasondemand"] = this.hasondemand;
        data["haspod"] = this.haspod;
        data["responsibleeditor"] = this.responsibleeditor;
        return data;
    }
}
class ProgramsResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.programs = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["programs"])) {
                this.programs = [];
                for (let item of _data["programs"])
                    this.programs.push(Program.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramsResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ProgramResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.program = new Program();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : new Program();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["program"] = this.program ? this.program.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class ProgramOverview {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramOverview();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
class Playlist {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        return data;
    }
}
class BroadcastFile {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new BroadcastFile();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        return data;
    }
}
class Broadcast {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.availablestoputc = _data["availablestoputc"] ? new Date(_data["availablestoputc"].toString()) : undefined;
            this.playlist = _data["playlist"] ? Playlist.fromJS(_data["playlist"]) : undefined;
            if (Array.isArray(_data["broadcastfiles"])) {
                this.broadcastfiles = [];
                for (let item of _data["broadcastfiles"])
                    this.broadcastfiles.push(BroadcastFile.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Broadcast();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["availablestoputc"] = this.availablestoputc ? this.availablestoputc.toISOString() : undefined;
        data["playlist"] = this.playlist ? this.playlist.toJSON() : undefined;
        if (Array.isArray(this.broadcastfiles)) {
            data["broadcastfiles"] = [];
            for (let item of this.broadcastfiles)
                data["broadcastfiles"].push(item.toJSON());
        }
        return data;
    }
}
class PodFile {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.filesizeinbytes = _data["filesizeinbytes"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
            this.availablefromutc = _data["availablefromutc"] ? new Date(_data["availablefromutc"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new PodFile();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["filesizeinbytes"] = this.filesizeinbytes;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        data["availablefromutc"] = this.availablefromutc ? this.availablefromutc.toISOString() : undefined;
        return data;
    }
}
class NewsPodFile {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.filesizeinbytes = _data["filesizeinbytes"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new NewsPodFile();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["filesizeinbytes"] = this.filesizeinbytes;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        return data;
    }
}
class BroadcastTime {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new BroadcastTime();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : undefined;
        return data;
    }
}
class Episode {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.channelid = _data["channelid"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
            this.audiopreference = _data["audiopreference"];
            this.audiopriority = _data["audiopriority"];
            this.audiopresentation = _data["audiopresentation"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : undefined;
            this.broadcasttime = _data["broadcasttime"] ? BroadcastTime.fromJS(_data["broadcasttime"]) : undefined;
            this.listenpodfile = _data["listenpodfile"] ? PodFile.fromJS(_data["listenpodfile"]) : undefined;
            this.downloadpodfile = _data["downloadpodfile"] ? PodFile.fromJS(_data["downloadpodfile"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Episode();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["url"] = this.url;
        data["channelid"] = this.channelid;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        data["audiopreference"] = this.audiopreference;
        data["audiopriority"] = this.audiopriority;
        data["audiopresentation"] = this.audiopresentation;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : undefined;
        data["broadcasttime"] = this.broadcasttime ? this.broadcasttime.toJSON() : undefined;
        data["listenpodfile"] = this.listenpodfile ? this.listenpodfile.toJSON() : undefined;
        data["downloadpodfile"] = this.downloadpodfile ? this.downloadpodfile.toJSON() : undefined;
        return data;
    }
}
class EpisodesResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.episodes = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["episodes"])) {
                this.episodes = [];
                for (let item of _data["episodes"])
                    this.episodes.push(Episode.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EpisodesResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.episodes)) {
            data["episodes"] = [];
            for (let item of this.episodes)
                data["episodes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class EpisodeResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.episode = new Episode();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.episode = _data["episode"] ? Episode.fromJS(_data["episode"]) : new Episode();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new EpisodeResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["episode"] = this.episode ? this.episode.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class NewsEpisode {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.channelid = _data["channelid"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
            this.audiopreference = _data["audiopreference"];
            this.audiopriority = _data["audiopriority"];
            this.audiopresentation = _data["audiopresentation"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : undefined;
            this.broadcasttime = _data["broadcasttime"] ? BroadcastTime.fromJS(_data["broadcasttime"]) : undefined;
            this.listenpodfile = _data["listenpodfile"] ? NewsPodFile.fromJS(_data["listenpodfile"]) : undefined;
            this.downloadpodfile = _data["downloadpodfile"] ? NewsPodFile.fromJS(_data["downloadpodfile"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new NewsEpisode();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["url"] = this.url;
        data["channelid"] = this.channelid;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        data["audiopreference"] = this.audiopreference;
        data["audiopriority"] = this.audiopriority;
        data["audiopresentation"] = this.audiopresentation;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : undefined;
        data["broadcasttime"] = this.broadcasttime ? this.broadcasttime.toJSON() : undefined;
        data["listenpodfile"] = this.listenpodfile ? this.listenpodfile.toJSON() : undefined;
        data["downloadpodfile"] = this.downloadpodfile ? this.downloadpodfile.toJSON() : undefined;
        return data;
    }
}
class Song {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.artist = _data["artist"];
            this.composer = _data["composer"];
            this.conductor = _data["conductor"];
            this.albumname = _data["albumname"];
            this.recordlabel = _data["recordlabel"];
            this.lyricist = _data["lyricist"];
            this.producer = _data["producer"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : undefined;
            this.stoptimeutc = _data["stoptimeutc"] ? new Date(_data["stoptimeutc"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Song();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["artist"] = this.artist;
        data["composer"] = this.composer;
        data["conductor"] = this.conductor;
        data["albumname"] = this.albumname;
        data["recordlabel"] = this.recordlabel;
        data["lyricist"] = this.lyricist;
        data["producer"] = this.producer;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : undefined;
        data["stoptimeutc"] = this.stoptimeutc ? this.stoptimeutc.toISOString() : undefined;
        return data;
    }
}
class RightNowPlaylist {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : undefined;
            this.previoussong = _data["previoussong"] ? Song.fromJS(_data["previoussong"]) : undefined;
            this.song = _data["song"] ? Song.fromJS(_data["song"]) : undefined;
            this.nextsong = _data["nextsong"] ? Song.fromJS(_data["nextsong"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new RightNowPlaylist();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        data["previoussong"] = this.previoussong ? this.previoussong.toJSON() : undefined;
        data["song"] = this.song ? this.song.toJSON() : undefined;
        data["nextsong"] = this.nextsong ? this.nextsong.toJSON() : undefined;
        return data;
    }
}
class RightNowPlaylistResponse {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.playlist = new RightNowPlaylist();
        }
    }
    init(_data) {
        if (_data) {
            this.playlist = _data["playlist"] ? RightNowPlaylist.fromJS(_data["playlist"]) : new RightNowPlaylist();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new RightNowPlaylistResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["playlist"] = this.playlist ? this.playlist.toJSON() : undefined;
        return data;
    }
}
class SonglistResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.song = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["song"])) {
                this.song = [];
                for (let item of _data["song"])
                    this.song.push(Song.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SonglistResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.song)) {
            data["song"] = [];
            for (let item of this.song)
                data["song"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class NewsProgramsResponse {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.programs = [];
        }
    }
    init(_data) {
        if (_data) {
            if (Array.isArray(_data["programs"])) {
                this.programs = [];
                for (let item of _data["programs"])
                    this.programs.push(Program.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new NewsProgramsResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        return data;
    }
}
class NewsEpisodesResponse {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.episodes = [];
        }
    }
    init(_data) {
        if (_data) {
            if (Array.isArray(_data["episodes"])) {
                this.episodes = [];
                for (let item of _data["episodes"])
                    this.episodes.push(NewsEpisode.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new NewsEpisodesResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.episodes)) {
            data["episodes"] = [];
            for (let item of this.episodes)
                data["episodes"].push(item.toJSON());
        }
        return data;
    }
}
class ExtraLiveAudio {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.url = _data["url"];
            this.statkey = _data["statkey"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraLiveAudio();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        return data;
    }
}
class ExtraPublisher {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraPublisher();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
class ExtraBroadcast {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sport = _data["sport"];
            this.description = _data["description"];
            this.localstarttime = _data["localstarttime"] ? new Date(_data["localstarttime"].toString()) : undefined;
            this.localstoptime = _data["localstoptime"] ? new Date(_data["localstoptime"].toString()) : undefined;
            this.publisher = _data["publisher"] ? ExtraPublisher.fromJS(_data["publisher"]) : undefined;
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : undefined;
            this.liveaudio = _data["liveaudio"] ? ExtraLiveAudio.fromJS(_data["liveaudio"]) : undefined;
            this.mobileliveaudio = _data["mobileliveaudio"] ? ExtraLiveAudio.fromJS(_data["mobileliveaudio"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraBroadcast();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sport"] = this.sport;
        data["description"] = this.description;
        data["localstarttime"] = this.localstarttime ? this.localstarttime.toISOString() : undefined;
        data["localstoptime"] = this.localstoptime ? this.localstoptime.toISOString() : undefined;
        data["publisher"] = this.publisher ? this.publisher.toJSON() : undefined;
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : undefined;
        data["mobileliveaudio"] = this.mobileliveaudio ? this.mobileliveaudio.toJSON() : undefined;
        return data;
    }
}
class ExtraBroadcastsResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.broadcasts = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["broadcasts"])) {
                this.broadcasts = [];
                for (let item of _data["broadcasts"])
                    this.broadcasts.push(ExtraBroadcast.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraBroadcastsResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.broadcasts)) {
            data["broadcasts"] = [];
            for (let item of this.broadcasts)
                data["broadcasts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ScheduledEpisode {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.episodeid = _data["episodeid"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEpisode();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["episodeid"] = this.episodeid;
        data["title"] = this.title;
        data["description"] = this.description;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : undefined;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        return data;
    }
}
class ScheduledEpisodeResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.schedule = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["schedule"])) {
                this.schedule = [];
                for (let item of _data["schedule"])
                    this.schedule.push(ScheduledEpisode.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEpisodeResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ChannelRightNowScheduledEpisode {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.episodeid = _data["episodeid"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
            this.socialimage = _data["socialimage"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNowScheduledEpisode();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["episodeid"] = this.episodeid;
        data["title"] = this.title;
        data["description"] = this.description;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : undefined;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        data["socialimage"] = this.socialimage;
        return data;
    }
}
class ChannelRightNow {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.previousscheduledepisode = _data["previousscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["previousscheduledepisode"]) : undefined;
            this.currentscheduledepisode = _data["currentscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["currentscheduledepisode"]) : undefined;
            this.nextscheduledepisode = _data["nextscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["nextscheduledepisode"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNow();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["previousscheduledepisode"] = this.previousscheduledepisode ? this.previousscheduledepisode.toJSON() : undefined;
        data["currentscheduledepisode"] = this.currentscheduledepisode ? this.currentscheduledepisode.toJSON() : undefined;
        data["nextscheduledepisode"] = this.nextscheduledepisode ? this.nextscheduledepisode.toJSON() : undefined;
        return data;
    }
}
class ChannelsRightNowResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.channels = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["channels"])) {
                this.channels = [];
                for (let item of _data["channels"])
                    this.channels.push(ChannelRightNow.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsRightNowResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.channels)) {
            data["channels"] = [];
            for (let item of this.channels)
                data["channels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ChannelRightNowResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.channel = new ChannelRightNow();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.channel = _data["channel"] ? ChannelRightNow.fromJS(_data["channel"]) : new ChannelRightNow();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNowResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class Show {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Show();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["type"] = this.type;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : undefined;
        data["program"] = this.program ? this.program.toJSON() : undefined;
        return data;
    }
}
class LastPublishedShowsResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.shows = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["shows"])) {
                this.shows = [];
                for (let item of _data["shows"])
                    this.shows.push(Show.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new LastPublishedShowsResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.shows)) {
            data["shows"] = [];
            for (let item of this.shows)
                data["shows"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class Message {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined;
            this.url = _data["url"];
            this.liveaudio = _data["liveaudio"] ? ExtraLiveAudio.fromJS(_data["liveaudio"]) : undefined;
            this.mobileliveaudio = _data["mobileliveaudio"] ? ExtraLiveAudio.fromJS(_data["mobileliveaudio"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["date"] = this.date ? this.date.toISOString() : undefined;
        data["url"] = this.url;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : undefined;
        data["mobileliveaudio"] = this.mobileliveaudio ? this.mobileliveaudio.toJSON() : undefined;
        return data;
    }
}
class MessagesResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.messages = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [];
                for (let item of _data["messages"])
                    this.messages.push(Message.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MessagesResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class TrafficArea {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.trafficdepartmentunitid = _data["trafficdepartmentunitid"];
            this.name = _data["name"];
            this.zoom = _data["zoom"];
            this.radius = _data["radius"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficArea();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["trafficdepartmentunitid"] = this.trafficdepartmentunitid;
        data["name"] = this.name;
        data["zoom"] = this.zoom;
        data["radius"] = this.radius;
        return data;
    }
}
class TrafficAreasResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.areas = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["areas"])) {
                this.areas = [];
                for (let item of _data["areas"])
                    this.areas.push(TrafficArea.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficAreasResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class TrafficAreaResponse extends BaseResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.area = new TrafficArea();
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.area = _data["area"] ? TrafficArea.fromJS(_data["area"]) : new TrafficArea();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficAreaResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area ? this.area.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
class TrafficMessage {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.priority = _data["priority"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined;
            this.exactlocation = _data["exactlocation"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.category = _data["category"];
            this.subcategory = _data["subcategory"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficMessage();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["priority"] = this.priority;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined;
        data["exactlocation"] = this.exactlocation;
        data["title"] = this.title;
        data["description"] = this.description;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["category"] = this.category;
        data["subcategory"] = this.subcategory;
        return data;
    }
}
class TrafficMessagesResponse extends PaginationResponse {
    constructor(data) {
        super(data);
        if (!data) {
            this.messages = [];
        }
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [];
                for (let item of _data["messages"])
                    this.messages.push(TrafficMessage.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficMessagesResponse();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}
class ApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isApiException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isApiException(obj) {
        return obj.isApiException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
//# sourceMappingURL=SrApiClient.js.map