/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

class SrApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.sr.se/api/v2";
    }

    /**
     * Get channels.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param sort (optional) 
     * @param liveAudioTemplateId (optional) Valid values are 2-5 and 10-12. Will be 2 (mp3) if omitted.
     * @param audioquality (optional) Only supported then liveAudioTemplateId is 2-5.
     * @return OK
     */
    getChannels(format: Format, page: number | undefined, size: number | undefined, sort: ChannelSort | undefined, liveAudioTemplateId: number | undefined, audioquality: AudioQuality | undefined): Promise<ChannelsResponse> {
        let url_ = this.baseUrl + "/channels?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (liveAudioTemplateId === null)
            throw new Error("The parameter 'liveAudioTemplateId' cannot be null.");
        else if (liveAudioTemplateId !== undefined)
            url_ += "liveAudioTemplateId=" + encodeURIComponent("" + liveAudioTemplateId) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChannels(_response);
        });
    }

    protected processGetChannels(response: Response): Promise<ChannelsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelsResponse>(<any>null);
    }

    /**
     * Get a single channel.
     * @param format Format of response. Has to be json.
     * @param id Id of channel
     * @param liveAudioTemplateId (optional) Valid values are 2-5 and 10-12. Will be 2 (mp3) if omitted.
     * @param audioquality (optional) Only supported then liveAudioTemplateId is 2-5.
     * @return OK
     */
    getChannel(format: Format, id: number, liveAudioTemplateId: number | undefined, audioquality: AudioQuality | undefined): Promise<ChannelResponse> {
        let url_ = this.baseUrl + "/channels/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (liveAudioTemplateId === null)
            throw new Error("The parameter 'liveAudioTemplateId' cannot be null.");
        else if (liveAudioTemplateId !== undefined)
            url_ += "liveAudioTemplateId=" + encodeURIComponent("" + liveAudioTemplateId) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChannel(_response);
        });
    }

    protected processGetChannel(response: Response): Promise<ChannelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelResponse>(<any>null);
    }

    /**
     * Get program categories.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getProgramCategories(format: Format, page: number | undefined, size: number | undefined): Promise<ProgramCategoriesResponse> {
        let url_ = this.baseUrl + "/programcategories?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramCategories(_response);
        });
    }

    protected processGetProgramCategories(response: Response): Promise<ProgramCategoriesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramCategoriesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramCategoriesResponse>(<any>null);
    }

    /**
     * Get a single program category.
     * @param format Format of response. Has to be json.
     * @param id Id of program category
     * @return OK
     */
    getProgramCategory(format: Format, id: number): Promise<ProgramCategoryResponse> {
        let url_ = this.baseUrl + "/programcategories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramCategory(_response);
        });
    }

    protected processGetProgramCategory(response: Response): Promise<ProgramCategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramCategoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramCategoryResponse>(<any>null);
    }

    /**
     * Get programs.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param programCategoryId (optional) 
     * @param isArchived (optional) If program should be archived
     * @return OK
     */
    getPrograms(format: Format, page: number | undefined, size: number | undefined, programCategoryId: number | undefined, isArchived: boolean | undefined): Promise<ProgramsResponse> {
        let url_ = this.baseUrl + "/programs?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programCategoryId === null)
            throw new Error("The parameter 'programCategoryId' cannot be null.");
        else if (programCategoryId !== undefined)
            url_ += "programCategoryId=" + encodeURIComponent("" + programCategoryId) + "&";
        if (isArchived === null)
            throw new Error("The parameter 'isArchived' cannot be null.");
        else if (isArchived !== undefined)
            url_ += "isArchived=" + encodeURIComponent("" + isArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPrograms(_response);
        });
    }

    protected processGetPrograms(response: Response): Promise<ProgramsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramsResponse>(<any>null);
    }

    /**
     * Get a single program.
     * @param format Format of response. Has to be json.
     * @param id Id of program
     * @return OK
     */
    getProgram(format: Format, id: number): Promise<ProgramResponse> {
        let url_ = this.baseUrl + "/programs/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgram(_response);
        });
    }

    protected processGetProgram(response: Response): Promise<ProgramResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramResponse>(<any>null);
    }

    /**
     * Get episodes.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getEpisodes(format: Format, page: number | undefined, size: number | undefined, programId: number, fromDate: Date | undefined, toDate: Date | undefined, audioquality: AudioQuality | undefined): Promise<EpisodesResponse> {
        let url_ = this.baseUrl + "/episodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined and cannot be null.");
        else
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpisodes(_response);
        });
    }

    protected processGetEpisodes(response: Response): Promise<EpisodesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EpisodesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpisodesResponse>(<any>null);
    }

    /**
     * Get a single episode.
     * @param format Format of response. Has to be json.
     * @param id Id of episode
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getEpisode(format: Format, id: number, audioquality: AudioQuality | undefined): Promise<EpisodeResponse> {
        let url_ = this.baseUrl + "/episodes/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpisode(_response);
        });
    }

    protected processGetEpisode(response: Response): Promise<EpisodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EpisodeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpisodeResponse>(<any>null);
    }

    /**
     * Get current playlist for a channel.
     * @param format Format of response. Has to be json.
     * @param channelid Id of channel
     * @return OK
     */
    getPlaylistRightNow(format: Format, channelid: number): Promise<RightNowPlaylistResponse> {
        let url_ = this.baseUrl + "/playlists/rightnow?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (channelid === undefined || channelid === null)
            throw new Error("The parameter 'channelid' must be defined and cannot be null.");
        else
            url_ += "channelid=" + encodeURIComponent("" + channelid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlaylistRightNow(_response);
        });
    }

    protected processGetPlaylistRightNow(response: Response): Promise<RightNowPlaylistResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RightNowPlaylistResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RightNowPlaylistResponse>(<any>null);
    }

    /**
     * Get playlist for an channel.
     * @param format Format of response. Has to be json.
     * @param size (optional) Maximum number of songs to get. Default is 20.
     * @param id Id of channel
     * @param startDateTime (optional) From which time. If not provided, current date will be used.
     * @param endDateTime (optional) To which time. If not provided, startDateTime + 1 day will be used.
     * @return OK
     */
    getPlaylistByChannel(format: Format, size: number | undefined, id: number, startDateTime: Date | undefined, endDateTime: Date | undefined): Promise<SonglistResponse> {
        let url_ = this.baseUrl + "/playlists/getplaylistbychannelid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toJSON() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlaylistByChannel(_response);
        });
    }

    protected processGetPlaylistByChannel(response: Response): Promise<SonglistResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SonglistResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SonglistResponse>(<any>null);
    }

    /**
     * Get playlist for a program.
     * @param format Format of response. Has to be json.
     * @param size (optional) Maximum number of songs to get. Default is 20.
     * @param id Id of program
     * @param startDateTime (optional) From which time. If not provided, current date will be used.
     * @param endDateTime (optional) To which time. If not provided, startDateTime + 1 day will be used.
     * @return OK
     */
    getPlaylistByProgram(format: Format, size: number | undefined, id: number, startDateTime: Date | undefined, endDateTime: Date | undefined): Promise<SonglistResponse> {
        let url_ = this.baseUrl + "/playlists/getplaylistbyprogramid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toJSON() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlaylistByProgram(_response);
        });
    }

    protected processGetPlaylistByProgram(response: Response): Promise<SonglistResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SonglistResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SonglistResponse>(<any>null);
    }

    /**
     * Get playlist for an episode.
     * @param format Format of response. Has to be json.
     * @param id Id of epsiode
     * @return OK
     */
    getPlaylistByEpisode(format: Format, id: number): Promise<SonglistResponse> {
        let url_ = this.baseUrl + "/playlists/getplaylistbyepisodeid?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlaylistByEpisode(_response);
        });
    }

    protected processGetPlaylistByEpisode(response: Response): Promise<SonglistResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SonglistResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SonglistResponse>(<any>null);
    }

    /**
     * Get news programs.
     * @param format Format of response. Has to be json.
     * @return OK
     */
    getNewsPrograms(format: Format): Promise<NewsProgramsResponse> {
        let url_ = this.baseUrl + "/news?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewsPrograms(_response);
        });
    }

    protected processGetNewsPrograms(response: Response): Promise<NewsProgramsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsProgramsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsProgramsResponse>(<any>null);
    }

    /**
     * Get news episodes.
     * @param format Format of response. Has to be json.
     * @param audioquality (optional) Only affects broadcast files, not pod files.
     * @return OK
     */
    getNewsEpisodes(format: Format, audioquality: AudioQuality | undefined): Promise<NewsEpisodesResponse> {
        let url_ = this.baseUrl + "/news/episodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewsEpisodes(_response);
        });
    }

    protected processGetNewsEpisodes(response: Response): Promise<NewsEpisodesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewsEpisodesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsEpisodesResponse>(<any>null);
    }

    /**
     * Get extra broadcasts.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getExtraBroadcasts(format: Format, page: number | undefined, size: number | undefined): Promise<ExtraBroadcastsResponse> {
        let url_ = this.baseUrl + "/extra/broadcasts?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExtraBroadcasts(_response);
        });
    }

    protected processGetExtraBroadcasts(response: Response): Promise<ExtraBroadcastsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtraBroadcastsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtraBroadcastsResponse>(<any>null);
    }

    /**
     * Get scheduled episodes for a channel.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param channelId Id of channel.
     * @param date (optional) Date for schedule. If no date is provided current date will be used.
     * @return OK
     */
    getScheduledEpisodesForChannel(format: Format, page: number | undefined, size: number | undefined, channelId: number, date: Date | undefined): Promise<ScheduledEpisodeResponse> {
        let url_ = this.baseUrl + "/scheduledepisodes?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined and cannot be null.");
        else
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScheduledEpisodesForChannel(_response);
        });
    }

    protected processGetScheduledEpisodesForChannel(response: Response): Promise<ScheduledEpisodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduledEpisodeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScheduledEpisodeResponse>(<any>null);
    }

    /**
     * Get scheduled episodes for a program.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param programId Id of program.
     * @param fromdate (optional) From date for schedule. If only fromdate is provided schedule for the that date and the 21 days is returned.
     * @param todate (optional) To date for schedule. If only todate is provided schedule from today until todate is returned.
     * @return OK
     */
    getScheduledEpisodesForProgram(format: Format, page: number | undefined, size: number | undefined, programId: number, fromdate: Date | undefined, todate: Date | undefined): Promise<ScheduledEpisodeResponse> {
        let url_ = this.baseUrl + "/scheduledepisodes/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined and cannot be null.");
        else
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (fromdate === null)
            throw new Error("The parameter 'fromdate' cannot be null.");
        else if (fromdate !== undefined)
            url_ += "fromdate=" + encodeURIComponent(fromdate ? "" + fromdate.toJSON() : "") + "&";
        if (todate === null)
            throw new Error("The parameter 'todate' cannot be null.");
        else if (todate !== undefined)
            url_ += "todate=" + encodeURIComponent(todate ? "" + todate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScheduledEpisodesForProgram(_response);
        });
    }

    protected processGetScheduledEpisodesForProgram(response: Response): Promise<ScheduledEpisodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduledEpisodeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScheduledEpisodeResponse>(<any>null);
    }

    /**
     * Get was is playing right now on each channel.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getEpisodesRightNowAllChannels(format: Format, page: number | undefined, size: number | undefined): Promise<ChannelsRightNowResponse> {
        let url_ = this.baseUrl + "/scheduledepisodes/rightnow?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpisodesRightNowAllChannels(_response);
        });
    }

    protected processGetEpisodesRightNowAllChannels(response: Response): Promise<ChannelsRightNowResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelsRightNowResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelsRightNowResponse>(<any>null);
    }

    /**
     * Get was is playing right now on a single  channel.
     * @param format Format of response. Has to be json.
     * @param channelId Id of channel.
     * @return OK
     */
    getEpisodesRightNowForChannel(format: Format, channelId: number): Promise<ChannelRightNowResponse> {
        let url_ = this.baseUrl + "/scheduledepisodes/rightnow/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined and cannot be null.");
        else
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpisodesRightNowForChannel(_response);
        });
    }

    protected processGetEpisodesRightNowForChannel(response: Response): Promise<ChannelRightNowResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelRightNowResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelRightNowResponse>(<any>null);
    }

    /**
     * Get latest published broadcasts and pods.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param audioquality (optional) 
     * @return OK
     */
    getLastPublishedShows(format: Format, page: number | undefined, size: number | undefined, audioquality: AudioQuality | undefined): Promise<LastPublishedShowsResponse> {
        let url_ = this.baseUrl + "/lastpublished?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (audioquality === null)
            throw new Error("The parameter 'audioquality' cannot be null.");
        else if (audioquality !== undefined)
            url_ += "audioquality=" + encodeURIComponent("" + audioquality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastPublishedShows(_response);
        });
    }

    protected processGetLastPublishedShows(response: Response): Promise<LastPublishedShowsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LastPublishedShowsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastPublishedShowsResponse>(<any>null);
    }

    /**
     * Get important messages.
     * @param format Format of response. Has to be json.
     * @return OK
     */
    getImportantMessages(format: Format): Promise<MessagesResponse> {
        let url_ = this.baseUrl + "/vma?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImportantMessages(_response);
        });
    }

    protected processGetImportantMessages(response: Response): Promise<MessagesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessagesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessagesResponse>(<any>null);
    }

    /**
     * Get traffic areas.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @return OK
     */
    getTrafficAreas(format: Format, page: number | undefined, size: number | undefined): Promise<TrafficAreasResponse> {
        let url_ = this.baseUrl + "/traffic/areas?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrafficAreas(_response);
        });
    }

    protected processGetTrafficAreas(response: Response): Promise<TrafficAreasResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrafficAreasResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrafficAreasResponse>(<any>null);
    }

    /**
     * Get traffic area for a specific coordinate.
     * @param format Format of response. Has to be json.
     * @param latitude Latitude. Valid values -90 to 90.
     * @param longitude Longitude. Valid values -180 to 180.
     * @return OK
     */
    getTrafficArea(format: Format, latitude: number, longitude: number): Promise<TrafficAreaResponse> {
        let url_ = this.baseUrl + "/traffic/areas/?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrafficArea(_response);
        });
    }

    protected processGetTrafficArea(response: Response): Promise<TrafficAreaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrafficAreaResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrafficAreaResponse>(<any>null);
    }

    /**
     * Get traffic messages.
     * @param format Format of response. Has to be json.
     * @param page (optional) Page number.
     * @param size (optional) Size of each page.
     * @param trafficAreaName (optional) Name of traffic area.
     * @return OK
     */
    getTrafficMessages(format: Format, page: number | undefined, size: number | undefined, trafficAreaName: string | undefined): Promise<TrafficMessagesResponse> {
        let url_ = this.baseUrl + "/traffic/messages?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (trafficAreaName === null)
            throw new Error("The parameter 'trafficAreaName' cannot be null.");
        else if (trafficAreaName !== undefined)
            url_ += "trafficAreaName=" + encodeURIComponent("" + trafficAreaName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrafficMessages(_response);
        });
    }

    protected processGetTrafficMessages(response: Response): Promise<TrafficMessagesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrafficMessagesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrafficMessagesResponse>(<any>null);
    }
}

enum Format {
    Json = "json",
}

enum ChannelSort {
    Id = "id",
    Id_desc = "id desc",
    Name = "name",
    Name_desc = "name desc",
}

/** Seems to be supported by live audio template 2-5. Read more about details at https://sverigesradio.se/api/documentation/v2/metoder/ljud.html#kvalitet */
enum AudioQuality {
    Normal = "normal",
    Hi = "hi",
    Lo = "lo",
}

class Pagination implements IPagination {
    page!: number;
    size!: number;
    totalhits!: number;
    totalpages!: number;

    constructor(data?: IPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.size = _data["size"];
            this.totalhits = _data["totalhits"];
            this.totalpages = _data["totalpages"];
        }
    }

    static fromJS(data: any): Pagination {
        data = typeof data === 'object' ? data : {};
        let result = new Pagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["size"] = this.size;
        data["totalhits"] = this.totalhits;
        data["totalpages"] = this.totalpages;
        return data; 
    }
}

interface IPagination {
    page: number;
    size: number;
    totalhits: number;
    totalpages: number;
}

class BaseResponse implements IBaseResponse {
    copyright!: string;

    constructor(data?: IBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.copyright = _data["copyright"];
        }
    }

    static fromJS(data: any): BaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["copyright"] = this.copyright;
        return data; 
    }
}

interface IBaseResponse {
    copyright: string;
}

class PaginationResponse extends BaseResponse implements IPaginationResponse {
    pagination!: Pagination;

    constructor(data?: IPaginationResponse) {
        super(data);
        if (!data) {
            this.pagination = new Pagination();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pagination = _data["pagination"] ? Pagination.fromJS(_data["pagination"]) : new Pagination();
        }
    }

    static fromJS(data: any): PaginationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IPaginationResponse extends IBaseResponse {
    pagination: Pagination;
}

class LiveAudio implements ILiveAudio {
    id!: number;
    url!: string;
    statkey!: string;

    constructor(data?: ILiveAudio) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
        }
    }

    static fromJS(data: any): LiveAudio {
        data = typeof data === 'object' ? data : {};
        let result = new LiveAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        return data; 
    }
}

interface ILiveAudio {
    id: number;
    url: string;
    statkey: string;
}

class SocialMediaPlatform implements ISocialMediaPlatform {
    platform!: string;
    platformurl!: string;

    constructor(data?: ISocialMediaPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platform = _data["platform"];
            this.platformurl = _data["platformurl"];
        }
    }

    static fromJS(data: any): SocialMediaPlatform {
        data = typeof data === 'object' ? data : {};
        let result = new SocialMediaPlatform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platform"] = this.platform;
        data["platformurl"] = this.platformurl;
        return data; 
    }
}

interface ISocialMediaPlatform {
    platform: string;
    platformurl: string;
}

class Channel implements IChannel {
    id!: number;
    name!: string;
    image?: string;
    imagetemplate?: string;
    color?: string;
    tagline?: string;
    siteurl?: string;
    liveaudio?: LiveAudio;
    scheduleurl?: string;
    channeltype!: string;
    xmltvid?: string;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.imagetemplate = _data["imagetemplate"];
            this.color = _data["color"];
            this.tagline = _data["tagline"];
            this.siteurl = _data["siteurl"];
            this.liveaudio = _data["liveaudio"] ? LiveAudio.fromJS(_data["liveaudio"]) : <any>undefined;
            this.scheduleurl = _data["scheduleurl"];
            this.channeltype = _data["channeltype"];
            this.xmltvid = _data["xmltvid"];
        }
    }

    static fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["imagetemplate"] = this.imagetemplate;
        data["color"] = this.color;
        data["tagline"] = this.tagline;
        data["siteurl"] = this.siteurl;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : <any>undefined;
        data["scheduleurl"] = this.scheduleurl;
        data["channeltype"] = this.channeltype;
        data["xmltvid"] = this.xmltvid;
        return data; 
    }
}

interface IChannel {
    id: number;
    name: string;
    image?: string;
    imagetemplate?: string;
    color?: string;
    tagline?: string;
    siteurl?: string;
    liveaudio?: LiveAudio;
    scheduleurl?: string;
    channeltype: string;
    xmltvid?: string;
}

class ChannelOverview implements IChannelOverview {
    id?: number;
    name?: string;

    constructor(data?: IChannelOverview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ChannelOverview {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelOverview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

interface IChannelOverview {
    id?: number;
    name?: string;
}

class ChannelsResponse extends PaginationResponse implements IChannelsResponse {
    channels!: Channel[];

    constructor(data?: IChannelsResponse) {
        super(data);
        if (!data) {
            this.channels = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["channels"])) {
                this.channels = [] as any;
                for (let item of _data["channels"])
                    this.channels!.push(Channel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChannelsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.channels)) {
            data["channels"] = [];
            for (let item of this.channels)
                data["channels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IChannelsResponse extends IPaginationResponse {
    channels: Channel[];
}

class ChannelResponse extends BaseResponse implements IChannelResponse {
    channel!: Channel;

    constructor(data?: IChannelResponse) {
        super(data);
        if (!data) {
            this.channel = new Channel();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.channel = _data["channel"] ? Channel.fromJS(_data["channel"]) : new Channel();
        }
    }

    static fromJS(data: any): ChannelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IChannelResponse extends IBaseResponse {
    channel: Channel;
}

class ProgramCategory implements IProgramCategory {
    id!: number;
    name!: string;

    constructor(data?: IProgramCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

interface IProgramCategory {
    id: number;
    name: string;
}

class ProgramCategoriesResponse extends PaginationResponse implements IProgramCategoriesResponse {
    programcategories!: ProgramCategory[];

    constructor(data?: IProgramCategoriesResponse) {
        super(data);
        if (!data) {
            this.programcategories = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["programcategories"])) {
                this.programcategories = [] as any;
                for (let item of _data["programcategories"])
                    this.programcategories!.push(ProgramCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramCategoriesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategoriesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programcategories)) {
            data["programcategories"] = [];
            for (let item of this.programcategories)
                data["programcategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IProgramCategoriesResponse extends IPaginationResponse {
    programcategories: ProgramCategory[];
}

class ProgramCategoryResponse extends BaseResponse implements IProgramCategoryResponse {
    programcategory!: ProgramCategory;

    constructor(data?: IProgramCategoryResponse) {
        super(data);
        if (!data) {
            this.programcategory = new ProgramCategory();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.programcategory = _data["programcategory"] ? ProgramCategory.fromJS(_data["programcategory"]) : new ProgramCategory();
        }
    }

    static fromJS(data: any): ProgramCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programcategory"] = this.programcategory ? this.programcategory.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IProgramCategoryResponse extends IBaseResponse {
    programcategory: ProgramCategory;
}

class Program implements IProgram {
    id!: number;
    name!: string;
    description?: string;
    programcategory?: ProgramCategory;
    payoff?: string;
    email?: string;
    phone?: string;
    broadcastinfo?: string;
    channel?: ChannelOverview;
    socialmediaplatforms?: SocialMediaPlatform[];
    programurl?: string;
    programslug?: string;
    programimage?: string;
    programimagetemplate?: string;
    programimagewide?: string;
    programimagetemplatewide?: string;
    socialimage?: string;
    socialimagetemplate?: string;
    archived!: boolean;
    hasondemand!: boolean;
    haspod!: boolean;
    responsibleeditor?: string;

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.programcategory = _data["programcategory"] ? ProgramCategory.fromJS(_data["programcategory"]) : <any>undefined;
            this.payoff = _data["payoff"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.broadcastinfo = _data["broadcastinfo"];
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : <any>undefined;
            if (Array.isArray(_data["socialmediaplatforms"])) {
                this.socialmediaplatforms = [] as any;
                for (let item of _data["socialmediaplatforms"])
                    this.socialmediaplatforms!.push(SocialMediaPlatform.fromJS(item));
            }
            this.programurl = _data["programurl"];
            this.programslug = _data["programslug"];
            this.programimage = _data["programimage"];
            this.programimagetemplate = _data["programimagetemplate"];
            this.programimagewide = _data["programimagewide"];
            this.programimagetemplatewide = _data["programimagetemplatewide"];
            this.socialimage = _data["socialimage"];
            this.socialimagetemplate = _data["socialimagetemplate"];
            this.archived = _data["archived"];
            this.hasondemand = _data["hasondemand"];
            this.haspod = _data["haspod"];
            this.responsibleeditor = _data["responsibleeditor"];
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["programcategory"] = this.programcategory ? this.programcategory.toJSON() : <any>undefined;
        data["payoff"] = this.payoff;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["broadcastinfo"] = this.broadcastinfo;
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        if (Array.isArray(this.socialmediaplatforms)) {
            data["socialmediaplatforms"] = [];
            for (let item of this.socialmediaplatforms)
                data["socialmediaplatforms"].push(item.toJSON());
        }
        data["programurl"] = this.programurl;
        data["programslug"] = this.programslug;
        data["programimage"] = this.programimage;
        data["programimagetemplate"] = this.programimagetemplate;
        data["programimagewide"] = this.programimagewide;
        data["programimagetemplatewide"] = this.programimagetemplatewide;
        data["socialimage"] = this.socialimage;
        data["socialimagetemplate"] = this.socialimagetemplate;
        data["archived"] = this.archived;
        data["hasondemand"] = this.hasondemand;
        data["haspod"] = this.haspod;
        data["responsibleeditor"] = this.responsibleeditor;
        return data; 
    }
}

interface IProgram {
    id: number;
    name: string;
    description?: string;
    programcategory?: ProgramCategory;
    payoff?: string;
    email?: string;
    phone?: string;
    broadcastinfo?: string;
    channel?: ChannelOverview;
    socialmediaplatforms?: SocialMediaPlatform[];
    programurl?: string;
    programslug?: string;
    programimage?: string;
    programimagetemplate?: string;
    programimagewide?: string;
    programimagetemplatewide?: string;
    socialimage?: string;
    socialimagetemplate?: string;
    archived: boolean;
    hasondemand: boolean;
    haspod: boolean;
    responsibleeditor?: string;
}

class ProgramsResponse extends PaginationResponse implements IProgramsResponse {
    programs!: Program[];

    constructor(data?: IProgramsResponse) {
        super(data);
        if (!data) {
            this.programs = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(Program.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IProgramsResponse extends IPaginationResponse {
    programs: Program[];
}

class ProgramResponse extends BaseResponse implements IProgramResponse {
    program!: Program;

    constructor(data?: IProgramResponse) {
        super(data);
        if (!data) {
            this.program = new Program();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : new Program();
        }
    }

    static fromJS(data: any): ProgramResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IProgramResponse extends IBaseResponse {
    program: Program;
}

class ProgramOverview implements IProgramOverview {
    id!: number;
    name?: string;

    constructor(data?: IProgramOverview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProgramOverview {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramOverview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

interface IProgramOverview {
    id: number;
    name?: string;
}

class Playlist implements IPlaylist {
    id!: number;
    url!: string;
    statkey?: string;
    duration!: number;
    publishdateutc!: Date;

    constructor(data?: IPlaylist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Playlist {
        data = typeof data === 'object' ? data : {};
        let result = new Playlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        return data; 
    }
}

interface IPlaylist {
    id: number;
    url: string;
    statkey?: string;
    duration: number;
    publishdateutc: Date;
}

class BroadcastFile implements IBroadcastFile {
    id!: number;
    url!: string;
    statkey?: string;
    duration!: number;
    publishdateutc!: Date;

    constructor(data?: IBroadcastFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BroadcastFile {
        data = typeof data === 'object' ? data : {};
        let result = new BroadcastFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        return data; 
    }
}

interface IBroadcastFile {
    id: number;
    url: string;
    statkey?: string;
    duration: number;
    publishdateutc: Date;
}

class Broadcast implements IBroadcast {
    availablestoputc?: Date;
    playlist?: Playlist;
    broadcastfiles?: BroadcastFile[];

    constructor(data?: IBroadcast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.availablestoputc = _data["availablestoputc"] ? new Date(_data["availablestoputc"].toString()) : <any>undefined;
            this.playlist = _data["playlist"] ? Playlist.fromJS(_data["playlist"]) : <any>undefined;
            if (Array.isArray(_data["broadcastfiles"])) {
                this.broadcastfiles = [] as any;
                for (let item of _data["broadcastfiles"])
                    this.broadcastfiles!.push(BroadcastFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Broadcast {
        data = typeof data === 'object' ? data : {};
        let result = new Broadcast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["availablestoputc"] = this.availablestoputc ? this.availablestoputc.toISOString() : <any>undefined;
        data["playlist"] = this.playlist ? this.playlist.toJSON() : <any>undefined;
        if (Array.isArray(this.broadcastfiles)) {
            data["broadcastfiles"] = [];
            for (let item of this.broadcastfiles)
                data["broadcastfiles"].push(item.toJSON());
        }
        return data; 
    }
}

interface IBroadcast {
    availablestoputc?: Date;
    playlist?: Playlist;
    broadcastfiles?: BroadcastFile[];
}

class PodFile implements IPodFile {
    id!: number;
    url!: string;
    statkey?: string;
    duration!: number;
    publishdateutc!: Date;
    title?: string;
    description?: string;
    filesizeinbytes!: number;
    program?: ProgramOverview;
    availablefromutc!: Date;

    constructor(data?: IPodFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.filesizeinbytes = _data["filesizeinbytes"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
            this.availablefromutc = _data["availablefromutc"] ? new Date(_data["availablefromutc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PodFile {
        data = typeof data === 'object' ? data : {};
        let result = new PodFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["filesizeinbytes"] = this.filesizeinbytes;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["availablefromutc"] = this.availablefromutc ? this.availablefromutc.toISOString() : <any>undefined;
        return data; 
    }
}

interface IPodFile {
    id: number;
    url: string;
    statkey?: string;
    duration: number;
    publishdateutc: Date;
    title?: string;
    description?: string;
    filesizeinbytes: number;
    program?: ProgramOverview;
    availablefromutc: Date;
}

class NewsPodFile implements INewsPodFile {
    url!: string;
    statkey?: string;
    duration!: number;
    publishdateutc!: Date;
    title?: string;
    description?: string;
    filesizeinbytes!: number;
    program?: ProgramOverview;

    constructor(data?: INewsPodFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.statkey = _data["statkey"];
            this.duration = _data["duration"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.filesizeinbytes = _data["filesizeinbytes"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsPodFile {
        data = typeof data === 'object' ? data : {};
        let result = new NewsPodFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        data["duration"] = this.duration;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["filesizeinbytes"] = this.filesizeinbytes;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        return data; 
    }
}

interface INewsPodFile {
    url: string;
    statkey?: string;
    duration: number;
    publishdateutc: Date;
    title?: string;
    description?: string;
    filesizeinbytes: number;
    program?: ProgramOverview;
}

class BroadcastTime implements IBroadcastTime {
    starttimeutc!: Date;
    endtimeutc!: Date;

    constructor(data?: IBroadcastTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : <any>undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BroadcastTime {
        data = typeof data === 'object' ? data : {};
        let result = new BroadcastTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : <any>undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : <any>undefined;
        return data; 
    }
}

interface IBroadcastTime {
    starttimeutc: Date;
    endtimeutc: Date;
}

class Episode implements IEpisode {
    id!: number;
    title!: string;
    description?: string;
    url?: string;
    channelid?: number;
    program?: ProgramOverview;
    audiopreference?: string;
    audiopriority?: string;
    audiopresentation?: string;
    publishdateutc!: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    broadcasttime?: BroadcastTime;
    listenpodfile?: PodFile;
    downloadpodfile?: PodFile;

    constructor(data?: IEpisode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.channelid = _data["channelid"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
            this.audiopreference = _data["audiopreference"];
            this.audiopriority = _data["audiopriority"];
            this.audiopresentation = _data["audiopresentation"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : <any>undefined;
            this.broadcasttime = _data["broadcasttime"] ? BroadcastTime.fromJS(_data["broadcasttime"]) : <any>undefined;
            this.listenpodfile = _data["listenpodfile"] ? PodFile.fromJS(_data["listenpodfile"]) : <any>undefined;
            this.downloadpodfile = _data["downloadpodfile"] ? PodFile.fromJS(_data["downloadpodfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Episode {
        data = typeof data === 'object' ? data : {};
        let result = new Episode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["url"] = this.url;
        data["channelid"] = this.channelid;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["audiopreference"] = this.audiopreference;
        data["audiopriority"] = this.audiopriority;
        data["audiopresentation"] = this.audiopresentation;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : <any>undefined;
        data["broadcasttime"] = this.broadcasttime ? this.broadcasttime.toJSON() : <any>undefined;
        data["listenpodfile"] = this.listenpodfile ? this.listenpodfile.toJSON() : <any>undefined;
        data["downloadpodfile"] = this.downloadpodfile ? this.downloadpodfile.toJSON() : <any>undefined;
        return data; 
    }
}

interface IEpisode {
    id: number;
    title: string;
    description?: string;
    url?: string;
    channelid?: number;
    program?: ProgramOverview;
    audiopreference?: string;
    audiopriority?: string;
    audiopresentation?: string;
    publishdateutc: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    broadcasttime?: BroadcastTime;
    listenpodfile?: PodFile;
    downloadpodfile?: PodFile;
}

class EpisodesResponse extends PaginationResponse implements IEpisodesResponse {
    episodes!: Episode[];

    constructor(data?: IEpisodesResponse) {
        super(data);
        if (!data) {
            this.episodes = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["episodes"])) {
                this.episodes = [] as any;
                for (let item of _data["episodes"])
                    this.episodes!.push(Episode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EpisodesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EpisodesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.episodes)) {
            data["episodes"] = [];
            for (let item of this.episodes)
                data["episodes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IEpisodesResponse extends IPaginationResponse {
    episodes: Episode[];
}

class EpisodeResponse extends BaseResponse implements IEpisodeResponse {
    episode!: Episode;

    constructor(data?: IEpisodeResponse) {
        super(data);
        if (!data) {
            this.episode = new Episode();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.episode = _data["episode"] ? Episode.fromJS(_data["episode"]) : new Episode();
        }
    }

    static fromJS(data: any): EpisodeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EpisodeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episode"] = this.episode ? this.episode.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IEpisodeResponse extends IBaseResponse {
    episode: Episode;
}

class NewsEpisode implements INewsEpisode {
    id!: number;
    title!: string;
    description?: string;
    url?: string;
    channelid?: number;
    program?: ProgramOverview;
    audiopreference?: string;
    audiopriority?: string;
    audiopresentation?: string;
    publishdateutc!: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    broadcasttime?: BroadcastTime;
    listenpodfile?: NewsPodFile;
    downloadpodfile?: NewsPodFile;

    constructor(data?: INewsEpisode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.channelid = _data["channelid"];
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
            this.audiopreference = _data["audiopreference"];
            this.audiopriority = _data["audiopriority"];
            this.audiopresentation = _data["audiopresentation"];
            this.publishdateutc = _data["publishdateutc"] ? new Date(_data["publishdateutc"].toString()) : <any>undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : <any>undefined;
            this.broadcasttime = _data["broadcasttime"] ? BroadcastTime.fromJS(_data["broadcasttime"]) : <any>undefined;
            this.listenpodfile = _data["listenpodfile"] ? NewsPodFile.fromJS(_data["listenpodfile"]) : <any>undefined;
            this.downloadpodfile = _data["downloadpodfile"] ? NewsPodFile.fromJS(_data["downloadpodfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsEpisode {
        data = typeof data === 'object' ? data : {};
        let result = new NewsEpisode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["url"] = this.url;
        data["channelid"] = this.channelid;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["audiopreference"] = this.audiopreference;
        data["audiopriority"] = this.audiopriority;
        data["audiopresentation"] = this.audiopresentation;
        data["publishdateutc"] = this.publishdateutc ? this.publishdateutc.toISOString() : <any>undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : <any>undefined;
        data["broadcasttime"] = this.broadcasttime ? this.broadcasttime.toJSON() : <any>undefined;
        data["listenpodfile"] = this.listenpodfile ? this.listenpodfile.toJSON() : <any>undefined;
        data["downloadpodfile"] = this.downloadpodfile ? this.downloadpodfile.toJSON() : <any>undefined;
        return data; 
    }
}

interface INewsEpisode {
    id: number;
    title: string;
    description?: string;
    url?: string;
    channelid?: number;
    program?: ProgramOverview;
    audiopreference?: string;
    audiopriority?: string;
    audiopresentation?: string;
    publishdateutc: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    broadcasttime?: BroadcastTime;
    listenpodfile?: NewsPodFile;
    downloadpodfile?: NewsPodFile;
}

class Song implements ISong {
    title!: string;
    description?: string;
    artist?: string;
    composer?: string;
    conductor?: string;
    albumname?: string;
    recordlabel?: string;
    lyricist?: string;
    producer?: string;
    starttimeutc!: Date;
    stoptimeutc!: Date;

    constructor(data?: ISong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.artist = _data["artist"];
            this.composer = _data["composer"];
            this.conductor = _data["conductor"];
            this.albumname = _data["albumname"];
            this.recordlabel = _data["recordlabel"];
            this.lyricist = _data["lyricist"];
            this.producer = _data["producer"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : <any>undefined;
            this.stoptimeutc = _data["stoptimeutc"] ? new Date(_data["stoptimeutc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Song {
        data = typeof data === 'object' ? data : {};
        let result = new Song();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["artist"] = this.artist;
        data["composer"] = this.composer;
        data["conductor"] = this.conductor;
        data["albumname"] = this.albumname;
        data["recordlabel"] = this.recordlabel;
        data["lyricist"] = this.lyricist;
        data["producer"] = this.producer;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : <any>undefined;
        data["stoptimeutc"] = this.stoptimeutc ? this.stoptimeutc.toISOString() : <any>undefined;
        return data; 
    }
}

interface ISong {
    title: string;
    description?: string;
    artist?: string;
    composer?: string;
    conductor?: string;
    albumname?: string;
    recordlabel?: string;
    lyricist?: string;
    producer?: string;
    starttimeutc: Date;
    stoptimeutc: Date;
}

class RightNowPlaylist implements IRightNowPlaylist {
    channel?: ChannelOverview;
    previoussong?: Song;
    song?: Song;
    nextsong?: Song;

    constructor(data?: IRightNowPlaylist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : <any>undefined;
            this.previoussong = _data["previoussong"] ? Song.fromJS(_data["previoussong"]) : <any>undefined;
            this.song = _data["song"] ? Song.fromJS(_data["song"]) : <any>undefined;
            this.nextsong = _data["nextsong"] ? Song.fromJS(_data["nextsong"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RightNowPlaylist {
        data = typeof data === 'object' ? data : {};
        let result = new RightNowPlaylist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        data["previoussong"] = this.previoussong ? this.previoussong.toJSON() : <any>undefined;
        data["song"] = this.song ? this.song.toJSON() : <any>undefined;
        data["nextsong"] = this.nextsong ? this.nextsong.toJSON() : <any>undefined;
        return data; 
    }
}

interface IRightNowPlaylist {
    channel?: ChannelOverview;
    previoussong?: Song;
    song?: Song;
    nextsong?: Song;
}

class RightNowPlaylistResponse implements IRightNowPlaylistResponse {
    playlist!: RightNowPlaylist;

    constructor(data?: IRightNowPlaylistResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.playlist = new RightNowPlaylist();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playlist = _data["playlist"] ? RightNowPlaylist.fromJS(_data["playlist"]) : new RightNowPlaylist();
        }
    }

    static fromJS(data: any): RightNowPlaylistResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RightNowPlaylistResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playlist"] = this.playlist ? this.playlist.toJSON() : <any>undefined;
        return data; 
    }
}

interface IRightNowPlaylistResponse {
    playlist: RightNowPlaylist;
}

class SonglistResponse extends BaseResponse implements ISonglistResponse {
    song!: Song[];

    constructor(data?: ISonglistResponse) {
        super(data);
        if (!data) {
            this.song = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["song"])) {
                this.song = [] as any;
                for (let item of _data["song"])
                    this.song!.push(Song.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SonglistResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SonglistResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.song)) {
            data["song"] = [];
            for (let item of this.song)
                data["song"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface ISonglistResponse extends IBaseResponse {
    song: Song[];
}

class NewsProgramsResponse implements INewsProgramsResponse {
    programs!: Program[];

    constructor(data?: INewsProgramsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.programs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(Program.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewsProgramsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NewsProgramsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        return data; 
    }
}

interface INewsProgramsResponse {
    programs: Program[];
}

class NewsEpisodesResponse implements INewsEpisodesResponse {
    episodes!: NewsEpisode[];

    constructor(data?: INewsEpisodesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.episodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["episodes"])) {
                this.episodes = [] as any;
                for (let item of _data["episodes"])
                    this.episodes!.push(NewsEpisode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewsEpisodesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NewsEpisodesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.episodes)) {
            data["episodes"] = [];
            for (let item of this.episodes)
                data["episodes"].push(item.toJSON());
        }
        return data; 
    }
}

interface INewsEpisodesResponse {
    episodes: NewsEpisode[];
}

class ExtraLiveAudio implements IExtraLiveAudio {
    url?: string;
    statkey?: string;

    constructor(data?: IExtraLiveAudio) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.statkey = _data["statkey"];
        }
    }

    static fromJS(data: any): ExtraLiveAudio {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraLiveAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["statkey"] = this.statkey;
        return data; 
    }
}

interface IExtraLiveAudio {
    url?: string;
    statkey?: string;
}

class ExtraPublisher implements IExtraPublisher {
    id?: number;
    name?: string;

    constructor(data?: IExtraPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ExtraPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

interface IExtraPublisher {
    id?: number;
    name?: string;
}

class ExtraBroadcast implements IExtraBroadcast {
    id!: number;
    name!: string;
    sport!: boolean;
    description?: string;
    localstarttime!: Date;
    localstoptime!: Date;
    publisher?: ExtraPublisher;
    channel?: ChannelOverview;
    liveaudio?: ExtraLiveAudio;
    mobileliveaudio?: ExtraLiveAudio;

    constructor(data?: IExtraBroadcast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sport = _data["sport"];
            this.description = _data["description"];
            this.localstarttime = _data["localstarttime"] ? new Date(_data["localstarttime"].toString()) : <any>undefined;
            this.localstoptime = _data["localstoptime"] ? new Date(_data["localstoptime"].toString()) : <any>undefined;
            this.publisher = _data["publisher"] ? ExtraPublisher.fromJS(_data["publisher"]) : <any>undefined;
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : <any>undefined;
            this.liveaudio = _data["liveaudio"] ? ExtraLiveAudio.fromJS(_data["liveaudio"]) : <any>undefined;
            this.mobileliveaudio = _data["mobileliveaudio"] ? ExtraLiveAudio.fromJS(_data["mobileliveaudio"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtraBroadcast {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraBroadcast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sport"] = this.sport;
        data["description"] = this.description;
        data["localstarttime"] = this.localstarttime ? this.localstarttime.toISOString() : <any>undefined;
        data["localstoptime"] = this.localstoptime ? this.localstoptime.toISOString() : <any>undefined;
        data["publisher"] = this.publisher ? this.publisher.toJSON() : <any>undefined;
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : <any>undefined;
        data["mobileliveaudio"] = this.mobileliveaudio ? this.mobileliveaudio.toJSON() : <any>undefined;
        return data; 
    }
}

interface IExtraBroadcast {
    id: number;
    name: string;
    sport: boolean;
    description?: string;
    localstarttime: Date;
    localstoptime: Date;
    publisher?: ExtraPublisher;
    channel?: ChannelOverview;
    liveaudio?: ExtraLiveAudio;
    mobileliveaudio?: ExtraLiveAudio;
}

class ExtraBroadcastsResponse extends PaginationResponse implements IExtraBroadcastsResponse {
    broadcasts!: ExtraBroadcast[];

    constructor(data?: IExtraBroadcastsResponse) {
        super(data);
        if (!data) {
            this.broadcasts = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["broadcasts"])) {
                this.broadcasts = [] as any;
                for (let item of _data["broadcasts"])
                    this.broadcasts!.push(ExtraBroadcast.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtraBroadcastsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraBroadcastsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.broadcasts)) {
            data["broadcasts"] = [];
            for (let item of this.broadcasts)
                data["broadcasts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IExtraBroadcastsResponse extends IPaginationResponse {
    broadcasts: ExtraBroadcast[];
}

class ScheduledEpisode implements IScheduledEpisode {
    episodeid?: number;
    title!: string;
    description?: string;
    starttimeutc!: Date;
    endtimeutc!: Date;
    program?: ProgramOverview;
    channel?: ChannelOverview;
    imageurl?: string;
    imageurltemplate?: string;

    constructor(data?: IScheduledEpisode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.episodeid = _data["episodeid"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : <any>undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : <any>undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
            this.channel = _data["channel"] ? ChannelOverview.fromJS(_data["channel"]) : <any>undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
        }
    }

    static fromJS(data: any): ScheduledEpisode {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEpisode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episodeid"] = this.episodeid;
        data["title"] = this.title;
        data["description"] = this.description;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : <any>undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : <any>undefined;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        return data; 
    }
}

interface IScheduledEpisode {
    episodeid?: number;
    title: string;
    description?: string;
    starttimeutc: Date;
    endtimeutc: Date;
    program?: ProgramOverview;
    channel?: ChannelOverview;
    imageurl?: string;
    imageurltemplate?: string;
}

class ScheduledEpisodeResponse extends PaginationResponse implements IScheduledEpisodeResponse {
    schedule!: ScheduledEpisode[];

    constructor(data?: IScheduledEpisodeResponse) {
        super(data);
        if (!data) {
            this.schedule = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["schedule"])) {
                this.schedule = [] as any;
                for (let item of _data["schedule"])
                    this.schedule!.push(ScheduledEpisode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduledEpisodeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledEpisodeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IScheduledEpisodeResponse extends IPaginationResponse {
    schedule: ScheduledEpisode[];
}

class ChannelRightNowScheduledEpisode implements IChannelRightNowScheduledEpisode {
    episodeid?: number;
    title!: string;
    description?: string;
    starttimeutc!: Date;
    endtimeutc!: Date;
    program?: ProgramOverview;
    socialimage?: string;

    constructor(data?: IChannelRightNowScheduledEpisode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.episodeid = _data["episodeid"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : <any>undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : <any>undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
            this.socialimage = _data["socialimage"];
        }
    }

    static fromJS(data: any): ChannelRightNowScheduledEpisode {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNowScheduledEpisode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episodeid"] = this.episodeid;
        data["title"] = this.title;
        data["description"] = this.description;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : <any>undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : <any>undefined;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["socialimage"] = this.socialimage;
        return data; 
    }
}

interface IChannelRightNowScheduledEpisode {
    episodeid?: number;
    title: string;
    description?: string;
    starttimeutc: Date;
    endtimeutc: Date;
    program?: ProgramOverview;
    socialimage?: string;
}

class ChannelRightNow implements IChannelRightNow {
    id!: number;
    name!: string;
    previousscheduledepisode?: ChannelRightNowScheduledEpisode;
    currentscheduledepisode?: ChannelRightNowScheduledEpisode;
    nextscheduledepisode?: ChannelRightNowScheduledEpisode;

    constructor(data?: IChannelRightNow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.previousscheduledepisode = _data["previousscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["previousscheduledepisode"]) : <any>undefined;
            this.currentscheduledepisode = _data["currentscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["currentscheduledepisode"]) : <any>undefined;
            this.nextscheduledepisode = _data["nextscheduledepisode"] ? ChannelRightNowScheduledEpisode.fromJS(_data["nextscheduledepisode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChannelRightNow {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["previousscheduledepisode"] = this.previousscheduledepisode ? this.previousscheduledepisode.toJSON() : <any>undefined;
        data["currentscheduledepisode"] = this.currentscheduledepisode ? this.currentscheduledepisode.toJSON() : <any>undefined;
        data["nextscheduledepisode"] = this.nextscheduledepisode ? this.nextscheduledepisode.toJSON() : <any>undefined;
        return data; 
    }
}

interface IChannelRightNow {
    id: number;
    name: string;
    previousscheduledepisode?: ChannelRightNowScheduledEpisode;
    currentscheduledepisode?: ChannelRightNowScheduledEpisode;
    nextscheduledepisode?: ChannelRightNowScheduledEpisode;
}

class ChannelsRightNowResponse extends PaginationResponse implements IChannelsRightNowResponse {
    channels!: ChannelRightNow[];

    constructor(data?: IChannelsRightNowResponse) {
        super(data);
        if (!data) {
            this.channels = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["channels"])) {
                this.channels = [] as any;
                for (let item of _data["channels"])
                    this.channels!.push(ChannelRightNow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChannelsRightNowResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsRightNowResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.channels)) {
            data["channels"] = [];
            for (let item of this.channels)
                data["channels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IChannelsRightNowResponse extends IPaginationResponse {
    channels: ChannelRightNow[];
}

class ChannelRightNowResponse extends BaseResponse implements IChannelRightNowResponse {
    channel!: ChannelRightNow;

    constructor(data?: IChannelRightNowResponse) {
        super(data);
        if (!data) {
            this.channel = new ChannelRightNow();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.channel = _data["channel"] ? ChannelRightNow.fromJS(_data["channel"]) : new ChannelRightNow();
        }
    }

    static fromJS(data: any): ChannelRightNowResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelRightNowResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface IChannelRightNowResponse extends IBaseResponse {
    channel: ChannelRightNow;
}

class Show implements IShow {
    id!: number;
    title!: string;
    description?: string;
    type?: string;
    starttimeutc!: Date;
    endtimeutc?: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    program?: ProgramOverview;

    constructor(data?: IShow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.starttimeutc = _data["starttimeutc"] ? new Date(_data["starttimeutc"].toString()) : <any>undefined;
            this.endtimeutc = _data["endtimeutc"] ? new Date(_data["endtimeutc"].toString()) : <any>undefined;
            this.imageurl = _data["imageurl"];
            this.imageurltemplate = _data["imageurltemplate"];
            this.broadcast = _data["broadcast"] ? Broadcast.fromJS(_data["broadcast"]) : <any>undefined;
            this.program = _data["program"] ? ProgramOverview.fromJS(_data["program"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Show {
        data = typeof data === 'object' ? data : {};
        let result = new Show();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["type"] = this.type;
        data["starttimeutc"] = this.starttimeutc ? this.starttimeutc.toISOString() : <any>undefined;
        data["endtimeutc"] = this.endtimeutc ? this.endtimeutc.toISOString() : <any>undefined;
        data["imageurl"] = this.imageurl;
        data["imageurltemplate"] = this.imageurltemplate;
        data["broadcast"] = this.broadcast ? this.broadcast.toJSON() : <any>undefined;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        return data; 
    }
}

interface IShow {
    id: number;
    title: string;
    description?: string;
    type?: string;
    starttimeutc: Date;
    endtimeutc?: Date;
    imageurl?: string;
    imageurltemplate?: string;
    broadcast?: Broadcast;
    program?: ProgramOverview;
}

class LastPublishedShowsResponse extends PaginationResponse implements ILastPublishedShowsResponse {
    shows!: Show[];

    constructor(data?: ILastPublishedShowsResponse) {
        super(data);
        if (!data) {
            this.shows = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["shows"])) {
                this.shows = [] as any;
                for (let item of _data["shows"])
                    this.shows!.push(Show.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LastPublishedShowsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LastPublishedShowsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.shows)) {
            data["shows"] = [];
            for (let item of this.shows)
                data["shows"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface ILastPublishedShowsResponse extends IPaginationResponse {
    shows: Show[];
}

class Message implements IMessage {
    id!: number;
    title!: string;
    description?: string;
    date!: Date;
    url?: string;
    liveaudio?: ExtraLiveAudio;
    mobileliveaudio?: ExtraLiveAudio;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.liveaudio = _data["liveaudio"] ? ExtraLiveAudio.fromJS(_data["liveaudio"]) : <any>undefined;
            this.mobileliveaudio = _data["mobileliveaudio"] ? ExtraLiveAudio.fromJS(_data["mobileliveaudio"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["liveaudio"] = this.liveaudio ? this.liveaudio.toJSON() : <any>undefined;
        data["mobileliveaudio"] = this.mobileliveaudio ? this.mobileliveaudio.toJSON() : <any>undefined;
        return data; 
    }
}

interface IMessage {
    id: number;
    title: string;
    description?: string;
    date: Date;
    url?: string;
    liveaudio?: ExtraLiveAudio;
    mobileliveaudio?: ExtraLiveAudio;
}

class MessagesResponse extends BaseResponse implements IMessagesResponse {
    messages!: Message[];

    constructor(data?: IMessagesResponse) {
        super(data);
        if (!data) {
            this.messages = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface IMessagesResponse extends IBaseResponse {
    messages: Message[];
}

class TrafficArea implements ITrafficArea {
    trafficdepartmentunitid!: number;
    name!: string;
    zoom!: number;
    radius!: number;

    constructor(data?: ITrafficArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trafficdepartmentunitid = _data["trafficdepartmentunitid"];
            this.name = _data["name"];
            this.zoom = _data["zoom"];
            this.radius = _data["radius"];
        }
    }

    static fromJS(data: any): TrafficArea {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trafficdepartmentunitid"] = this.trafficdepartmentunitid;
        data["name"] = this.name;
        data["zoom"] = this.zoom;
        data["radius"] = this.radius;
        return data; 
    }
}

interface ITrafficArea {
    trafficdepartmentunitid: number;
    name: string;
    zoom: number;
    radius: number;
}

class TrafficAreasResponse extends PaginationResponse implements ITrafficAreasResponse {
    areas!: TrafficArea[];

    constructor(data?: ITrafficAreasResponse) {
        super(data);
        if (!data) {
            this.areas = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(TrafficArea.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrafficAreasResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficAreasResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface ITrafficAreasResponse extends IPaginationResponse {
    areas: TrafficArea[];
}

class TrafficAreaResponse extends BaseResponse implements ITrafficAreaResponse {
    area!: TrafficArea;

    constructor(data?: ITrafficAreaResponse) {
        super(data);
        if (!data) {
            this.area = new TrafficArea();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.area = _data["area"] ? TrafficArea.fromJS(_data["area"]) : new TrafficArea();
        }
    }

    static fromJS(data: any): TrafficAreaResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficAreaResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

interface ITrafficAreaResponse extends IBaseResponse {
    area: TrafficArea;
}

class TrafficMessage implements ITrafficMessage {
    id!: number;
    priority!: number;
    createddate!: Date;
    exactlocation?: string;
    title?: string;
    description?: string;
    latitude!: number;
    longitude!: number;
    category!: number;
    subcategory!: string;

    constructor(data?: ITrafficMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.priority = _data["priority"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : <any>undefined;
            this.exactlocation = _data["exactlocation"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.category = _data["category"];
            this.subcategory = _data["subcategory"];
        }
    }

    static fromJS(data: any): TrafficMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["priority"] = this.priority;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["exactlocation"] = this.exactlocation;
        data["title"] = this.title;
        data["description"] = this.description;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["category"] = this.category;
        data["subcategory"] = this.subcategory;
        return data; 
    }
}

interface ITrafficMessage {
    id: number;
    priority: number;
    createddate: Date;
    exactlocation?: string;
    title?: string;
    description?: string;
    latitude: number;
    longitude: number;
    category: number;
    subcategory: string;
}

class TrafficMessagesResponse extends PaginationResponse implements ITrafficMessagesResponse {
    messages!: TrafficMessage[];

    constructor(data?: ITrafficMessagesResponse) {
        super(data);
        if (!data) {
            this.messages = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(TrafficMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrafficMessagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficMessagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

interface ITrafficMessagesResponse extends IPaginationResponse {
    messages: TrafficMessage[];
}

class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}